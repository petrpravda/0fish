
/*
class BB64Long {
  readonly lower: number;
  readonly upper: number;

  constructor(lower: number, upper: number): BB64Long;
  asBigInt(): bigint;
  empty(): boolean;
  isZero(idx: number): boolean;
  isOne(idx: number): boolean;
  setBit(idx: number): BB64Long;
  popcnt(): number;
  popLSB(): BB64Long;
  maskMostSignificantBit(): BB64Long;
  LSB(): number;
  AND(other: BB64Long): BB64Long;
  AND_NOT(other: BB64Long): BB64Long;
  OR(other: BB64Long): BB64Long;
  XOR(other: BB64Long): BB64Long;
  NOT(): BB64Long;
  SHL(v: number): BB64Long;
  SHR(v: number): BB64Long;
  SHIFT(v: number): BB64Long;
  subtract1(): BB64Long;
  equals(other: BB64Long): boolean;
}

class Bitboard {
  getKnightAttacks(knightPosition: number): BB64Long;
  getKingAttacks(kingPosition: number): BB64Long;
  getRookAttacks(rookPosition: number, occupied: BB64Long): BB64Long;
  getBishopAttacks(bishopPosition: number, occupied: BB64Long): BB64Long;
  getQueenAttacks(queenPosition: number, occupied: BB64Long): BB64Long;
  pawnAttacks(pawns: BB64Long, side: Side): BB64Long;
  pawnPush(pawn: BB64Long, side: Side): BB64Long;
  castlingPiecesKingsideMask(side: Side): BB64Long;
  castlingPiecesQueensideMask(side: Side): BB64Long;
  pawnAttacksFromSquare(square: number, side: Side): BB64Long;
  whiteLeftPawnAttacks(pawns: BB64Long): BB64Long;
  whiteRightPawnAttacks(pawns: BB64Long): BB64Long;
  blackLeftPawnAttacks(pawns: BB64Long): BB64Long;
  blackRightPawnAttacks(pawns: BB64Long): BB64Long;}

export const Side = {
  WHITE: 0,
  BLACK: 1,
} as const;


 */
